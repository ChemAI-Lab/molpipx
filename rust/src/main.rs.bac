#![feature(autodiff)]
#![feature(array_chunks)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_variables)]
// Allowing non_snake_case to match naming conventions.
// For simplification, this case study does hardcode the values of N, Nval, deg, and forces.

use pip::*;

// TODO: please adjust the degree if you wish.
mod monomials_deg_3;
mod polynomials_deg_3;
use monomials_deg_3::*;
use polynomials_deg_3::*;

use std::path::Path;
use pip::read_geometry_energy;

fn main() {
  training();
}

#[autodiff(db, Reverse, Duplicated, Duplicated)]
fn bytwo(x: &[f64], out: &mut [f64]) {
    for i in 0..x.len() {
        out[i] = x[i] * x[i];
    }
}

#[autodiff(dg, Reverse, Duplicated, Duplicated)]
fn g(params: &[f64; N_XYZ], morses: &mut [f64; N_DISTANCES]) {
    let mut res: [f64; N_DISTANCES] = dist(params);
    //morse(&mut res, 1.0);
    for i in 0..N_DISTANCES {
        morses[i] += res[i];
    }
}


#[autodiff(df_energy, Reverse, Duplicated, Const, Active)]
fn f_energy(x: &[f64; N_XYZ], w: &[f64; N_POLYS]) -> f64 {
    let mut res: [f64; N_DISTANCES] = dist(x);
    morse(&mut res, 1.0);
    let pip: [f64; N_POLYS] = f_polynomials(&res);
    let mut y = 0.0;
    for i in 0..N_POLYS {
        y += pip[i] * w[i];
    }
    y
}

#[autodiff(df, Reverse, Duplicated, Duplicated)]
fn f(params: &[f64; N_XYZ], pips: &mut [f64; N_POLYS]) {
    let mut res: [f64; N_DISTANCES] = dist(params);
    morse(&mut res, 1.0);
    let tmp: [f64; N_POLYS] = f_polynomials(&res);
    for i in 0..N_POLYS {
        pips[i] = tmp[i];
    }
}

fn training() {
    // /u/drehwald/prog/PIPMSA_jax/Data/Methane
    let path_to_xyz = Path::new("/u/drehwald/prog/PIPMSA_jax/Data/Methane/Methane.xyz");
    let (geometries, forces, energies, atoms) = read_geometry_energy(path_to_xyz);

    // split geometries and forces in half.
    let half = geometries.len() / 2;
    let (X_tr, X_val) = geometries.split_at(half);
    let half_e = energies.len() / 2;
    let (y_tr, y_val) = energies.split_at(half_e);
    let half_f = forces.len() / 2;
    let (F_tr, F_val) = forces.split_at(half_f);


    for x in X_tr.array_chunks::<N_XYZ>() {
        let mut dx = [0.0; N_XYZ];
        let mut out = [0.0; N_POLYS];
        let mut dout = [0.0; N_POLYS];
        dout[0] = 1.0;
        db(x, &mut dx, &mut out, &mut dout);
        dbg!(&dx);
        let mut distout = dist(&x);
        morse(&mut distout, 1.0);
        dbg!(&distout);

        let mut dx = [0.0; N_XYZ];
        let mut morses = [0.0; N_DISTANCES];
        let mut dmorses = [0.0; N_DISTANCES];
        dmorses[0] = 1.0;
        dbg!(&x);
        dg(&x, &mut dx, &mut morses, &mut dmorses);
        dbg!(&dx);

        for i in 0..N_XYZ {
            dbg!(&morses);
            dbg!(dx);
        }

        // primal
        //let mut pips = vec![0.0; N_POLYS];
        //f(&x, &mut pips);

        // wrt to params
        //for i in 0..N_POLYS {
        //    let mut dx = [0.0; N_XYZ];
        //    let mut pips = [0.0; N_POLYS];
        //    let mut grads = [0.0; N_POLYS];
        //    grads[i] = 1.0;
        //    df(&x, &mut dx, &mut pips, &mut grads);
        //    dbg!(dx);
        //}

    }




    //let w = mytraining(&X_tr, &y_tr);
    //    w = training(model_pip, X_tr, y_tr)

    //dbg!(atoms);
    //dbg!(&geometries.len());
    //assert!(geometries.len() % 10 == 0);
    //let mut output = Vec::new();
    //for geo in geometries.array_chunks::<10>() {
    //    dbg!(geo);
    //    let res = f_polynomials(&geo);
    //    output.push(res);
    //}
    

    //let model_pip = PIP(f_mono, f_poly);
    //let model_energy = EnergyPIP(f_mono, f_poly);
    //let params = model_energy.init(X_tr[0]);
    //let w = training(model_pip, X_tr, y_tr);
    //let params = flax_params(w, params);
    //let y_pred_tr = model_energy.apply(params, X_tr);
    //let y_pred_val = model_energy.apply(params, X_val);
    //let loss_tr = mse_loss(y_pred_tr, y_tr);
    //let loss_val = mse_loss(y_pred_val, y_val);
    //println!("{} {} {}", N, loss_tr, loss_val);
    //let results_file = format!("results_N_{}_pip_deg_{}.npy", N, deg);
    //jnp.save(results_file, results, allow_pickle = true);
}

